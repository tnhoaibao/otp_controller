`timescale 1ns/10ps

module otp_main (
	sys_clk,		//system clock, 200MHz clock generated by LO
	rst_n,			//power on reset, active low
	i_i2c_busy,		//input signal indicates that there is i2c transaction or not, 1-i2c transaction, 0-no i2c transaction
	i_run_test_mode,//input signal indicates that usb chip is in test mode or not, 1-test mode, 0-normal mode
	/* connect to otp */
	o_otp_vddqsw,	//enable high voltage LDO for efuse programming, disable for read
	o_otp_csb,		//otp select enable, active low for programming/reading
	o_otp_strobe,	//output signal used to turn on the array for read/program access
	o_otp_load,		//output signal used to turn on sense amplifier (in otp mem) and load data into latch (in otp mem)
	i_otp_q,		//parallel data from efuse
	o_otp_addr,		//address access to otp mem
	o_otp_pgenb,	//program enable, active low
	/* connect to reg file */
	o_xbus_din,		//data bus to access reg file
	o_xbus_addr,	//address bus to access reg file
	i_xbus_dout,	//data bus from reg file
	i_otp_read_n, 	//enable read mode of efuse controller, active low
	i_otp_prog,		//enable program mode of efuse controller
	o_xbus_wr,		//enable signal indicates read or write data to register file
	o_otp_busy 		//input signal indicates that there is otp transaction or not, 1-i2c transaction, 0-no i2c transaction
	);

parameter num_of_reg = 10; //number of registers will be loaded into otp memory
parameter [6:0] ADDR_ARRAY [0 : num_of_reg-1] = {7'd1,  7'd2,  7'd3,  7'd4,  7'd5,  7'd6,  7'd7,  7'd8,  7'd9,  7'd10}; 
//												 7'd11, 7'd12, 7'd13, 7'd14, 7'd15, 7'd16, 7'd17, 7'd18, 7'd19, 7'd20,
//												 7'd21, 7'd22, 7'd23, 7'd24, 7'd25, 7'd26, 7'd27, 7'd28, 7'd29, 7'd30,
//												 7'd31, 7'd32, 7'd33, 7'd34, 7'd35, 7'd36, 7'd37, 7'd38, 7'd39, 7'd40,
//												 7'd41, 7'd42, 7'd43, 7'd44, 7'd45, 7'd46, 7'd47, 7'd48, 7'd49, 7'd50,
//												 7'd51, 7'd52, 7'd53, 7'd54, 7'd55, 7'd56, 7'd57, 7'd58, 7'd59, 7'd60,
//												 7'd61, 7'd62, 7'd63, 7'd64, 7'd65, 7'd66, 7'd67, 7'd68, 7'd69, 7'd70,
//												 7'd71, 7'd72, 7'd73, 7'd74, 7'd75, 7'd76, 7'd77, 7'd78, 7'd79, 7'd80,
//												 7'd81, 7'd82, 7'd83, 7'd84, 7'd85, 7'd86, 7'd87, 7'd88, 7'd89, 7'd90,
//												 7'd91, 7'd92, 7'd93, 7'd94, 7'd95, 7'd96, 7'd97, 7'd98, 7'd99, 7'd100}; // example, define registers access to otp mem
// maximum count for start_pgm is 3 (SUP_PG timing)
parameter TSUP_PG = 3;
// maximum count for main_pgm is 1000 (PGM timing)
parameter TPGM = 100; //define smaller number to verify
// maximum count for finish_pgm is 3 (HP_PG timing)
parameter ADDR_DUMMY = 7'h7F;
// define register contains program and read enable
// it will be reset to default value after finish program or read operation
parameter RW_ADDR = 7'd99;
parameter RW_DATA = 8'hFF; 

input sys_clk;
input rst_n;
input i_i2c_busy;
input i_run_test_mode;

output o_otp_vddqsw;
output o_otp_csb;
output o_otp_strobe;
output o_otp_load;
input [7:0] i_otp_q;
output [9:0] o_otp_addr;
output o_otp_pgenb;

output [7:0] o_xbus_din;
output [6:0] o_xbus_addr;
input [7:0] i_xbus_dout;
input i_otp_read_n;
input i_otp_prog;
output o_xbus_wr;

output o_otp_busy;

reg i2c_busy_temp1;		// sync reg for i_i2c_busy
reg i2c_busy_temp2;		// sync reg for i_i2c_busy

reg [9:0] fsm_cnt_r;	//up counter for *_read and *_pgm state
wire [9:0] fsm_cnt_next_w;	

reg [6:0] num_reg_r;	//up counter used to count the number of register access in program/read mode, a transaction will be done if num_reg_r = num_of_reg
wire [6:0] num_reg_w; 

reg [6:0] efuse_byte_addr_r; 		//up counter for byte address = bit line + word line	
wire [6:0] efuse_byte_addr_next_w;	//efuse_addr = {efuse_no_bitline_r,efuse_byte_addr_r}
reg [2:0] efuse_no_bitline_r;		//up counter for the bit order
wire [2:0] efuse_no_bitline_next_w;

reg [7:0] xbus_addr_r;	//register address access to reg file
wire [7:0] xbus_addr_next_w;
wire [7:0] xbus_addr_rd_next_w;

reg efuse_csb_r;	//FF before out to pad
reg efuse_load_r;
reg efuse_vddq_r;
reg efuse_strobe_r;
reg efuse_pgenb_r;
reg [7:0] xbus_din_r;
reg xbus_wr_r;

// define states in fsm
typedef enum {IDLE, WAIT_I2C, START_READ, MAIN_READ, FINISH_READ, START_PGM, MAIN_PGM, FINISH_PGM, OTP_DONE} efuse_fsm_t;
efuse_fsm_t efuse_fsm_r, efuse_fsm_next_s;

// synchronize i_i2c_busy to sys_clk
always @(posedge sys_clk or negedge rst_n)
  begin
    if (rst_n == 0) begin
	  i2c_busy_temp1 <= 1'b0;
	  i2c_busy_temp2 <= 1'b0;
	end else begin
	  i2c_busy_temp1 <= i_i2c_busy;
	  i2c_busy_temp2 <= i2c_busy_temp1;
	end
  end

// implement fsm for otp controller
// specification v1.1
// Reset usb chip, the FSM moves to START_READ imediately to load otp data to reg
// Then, it moves to IDLE
// Once there is no i2c transaction and otp controller receives read/pgm start bit, the fsm moves to read/pgm cycle
always @(posedge sys_clk or negedge rst_n)
  begin
    if (rst_n == 0)
      efuse_fsm_r <= START_READ;
    else
      efuse_fsm_r <= efuse_fsm_next_s;
  end

always @(*)
  begin
    if ((i_run_test_mode == 0) && (efuse_fsm_r == WAIT_I2C)) 
      efuse_fsm_next_s = IDLE;
    else begin
      case (efuse_fsm_r)
		IDLE: efuse_fsm_next_s = WAIT_I2C;
		WAIT_I2C: if ((i2c_busy_temp2 == 1'b0) && (i_otp_prog == 1'b1))
						efuse_fsm_next_s = START_PGM;
					else if ((i2c_busy_temp2 == 1'b0) && (i_otp_read_n == 1'b0)) 
						efuse_fsm_next_s = START_READ;
					else if (i2c_busy_temp2 == 1'b1) 
						efuse_fsm_next_s = IDLE;
					else 
						efuse_fsm_next_s = WAIT_I2C;
		START_READ: if (fsm_cnt_r == 1) 
						efuse_fsm_next_s = MAIN_READ;
					else
						efuse_fsm_next_s = START_READ;
		MAIN_READ:  if ((num_reg_r == (num_of_reg - 1)) && (fsm_cnt_r == 3)) 
						efuse_fsm_next_s = FINISH_READ;
					else
						efuse_fsm_next_s = MAIN_READ;
		FINISH_READ: if (fsm_cnt_r == 1) 
						efuse_fsm_next_s = OTP_DONE;
					else
						efuse_fsm_next_s = FINISH_READ;
		START_PGM: if (fsm_cnt_r == 3) 
						efuse_fsm_next_s = MAIN_PGM;
					else
						efuse_fsm_next_s = START_PGM;
		MAIN_PGM: if ((num_reg_r == (num_of_reg - 1)) && (fsm_cnt_r == TPGM) && (efuse_no_bitline_r == 7)) 
						efuse_fsm_next_s = FINISH_PGM;
					else 
						efuse_fsm_next_s = MAIN_PGM;
		FINISH_PGM: if (fsm_cnt_r == 3) 
						efuse_fsm_next_s = OTP_DONE;
					else
						efuse_fsm_next_s = FINISH_PGM;
		OTP_DONE: if (fsm_cnt_r == 100)
						efuse_fsm_next_s = IDLE;
					else
						efuse_fsm_next_s = OTP_DONE;
		default: efuse_fsm_next_s = IDLE;
      endcase
    end
  end

// up counter
// counter for start_read, main_read and finish_read states
// maximum count for start_read is 1 (SUR_V timing)
// maximum count for main_read is 3 (RD timing + 1 clock for waiting)
// maximum count for finish_read is 1 (HP_V timing)
// use only 1 up counter for start_pgm, main_pgm and finish_pgm states 
// maximum count for start_pgm is 3 (SUP_PG timing)
// maximum count for main_pgm is 1000 (PGM timing)
// maximum count for finish_pgm is 3 (HP_PG timing)
always @(posedge sys_clk or negedge rst_n)
  begin
    if (rst_n == 0)
      fsm_cnt_r <= 0;
    else if (efuse_fsm_r == START_READ) begin
	  if (fsm_cnt_next_w == 2) fsm_cnt_r <= 0;
	  else fsm_cnt_r <= fsm_cnt_next_w;
	end else if (efuse_fsm_r == MAIN_READ) begin
	  if (fsm_cnt_next_w == 4) fsm_cnt_r <= 0;
	  else fsm_cnt_r <= fsm_cnt_next_w;
	end else if (efuse_fsm_r == FINISH_READ) begin
	  if (fsm_cnt_next_w == 2) fsm_cnt_r <= 0;
	  else fsm_cnt_r <= fsm_cnt_next_w;
	end else if (efuse_fsm_r == START_PGM) begin
	  if (fsm_cnt_next_w == 4) fsm_cnt_r <= 0;
	  else fsm_cnt_r <= fsm_cnt_next_w;
	end else if (efuse_fsm_r == MAIN_PGM) begin
	  if (fsm_cnt_next_w == (TPGM + 1)) fsm_cnt_r <= 0;
	  else fsm_cnt_r <= fsm_cnt_next_w;
	end else if (efuse_fsm_r == FINISH_PGM) begin
	  if (fsm_cnt_next_w == 4) fsm_cnt_r <= 0;
	  else fsm_cnt_r <= fsm_cnt_next_w;
	end else if (efuse_fsm_r == OTP_DONE) begin
	  if (fsm_cnt_next_w == 101) fsm_cnt_r <= 0;
	  else fsm_cnt_r <= fsm_cnt_next_w;
	end else fsm_cnt_r <= 0;
  end

assign fsm_cnt_next_w = fsm_cnt_r + 1;

// generate address to access otp memory
// otp memory address includes: 4 bits for Word line (efuse_wordline_r), 3 bits for Bit line (efuse_bitline_r) and 3 bits for the order of bit (efuse_no_bitline_r)
// combine 4 bits for Word line + 3 bits for Bit line = efuse_byte_addr_r
always @(posedge sys_clk or negedge rst_n)
  begin
    if (rst_n == 0)
	  efuse_byte_addr_r <= 0;
	else if (efuse_fsm_r == MAIN_READ) begin
	  if ((efuse_no_bitline_r == 7) && (fsm_cnt_r == 3)) efuse_byte_addr_r <= efuse_byte_addr_next_w;
	  else efuse_byte_addr_r <= efuse_byte_addr_r;
	end else if ( efuse_fsm_r == MAIN_PGM) begin
	  if ((efuse_no_bitline_r == 7) && (fsm_cnt_r == TPGM)) efuse_byte_addr_r <= efuse_byte_addr_next_w;
	  else efuse_byte_addr_r <= efuse_byte_addr_r;
	end else efuse_byte_addr_r <= 0;
  end
 
assign efuse_byte_addr_next_w = efuse_byte_addr_r + 1;

// 3 bits for the order of bit
always @(posedge sys_clk or negedge rst_n)
  begin
    if (rst_n == 0)
	  efuse_no_bitline_r <= 0;
	else if (efuse_fsm_r == MAIN_READ) begin
	  if (fsm_cnt_r == 3) efuse_no_bitline_r <= efuse_no_bitline_next_w;
	  else efuse_no_bitline_r <= efuse_no_bitline_r;
	end else if (efuse_fsm_r == MAIN_PGM) begin
	  if (fsm_cnt_r == TPGM) efuse_no_bitline_r <= efuse_no_bitline_next_w;
	  else efuse_no_bitline_r <= efuse_no_bitline_r;
	end else efuse_no_bitline_r <= 0;
  end
  
 assign efuse_no_bitline_next_w = efuse_no_bitline_r + 1;
 assign o_otp_addr = {efuse_no_bitline_r,efuse_byte_addr_r};

// generate xbus_addr to access register file (in read mode)
// load data from otp mem valid legally at falling edge of otp_strobe
// xbus_addr access to register file in this case must be sent at the moment
// generate xbus_addr to access register file (in program mode)
// program data to otp mem 
always @(posedge sys_clk or negedge rst_n)
  begin
    if (rst_n == 0) begin
      xbus_addr_r <= ADDR_ARRAY[0];
	  num_reg_r <= 0;
    end else if (efuse_fsm_r == MAIN_PGM) begin
      if ((fsm_cnt_r == TPGM) && (efuse_no_bitline_r == 3'b111)) begin 
	    xbus_addr_r <= xbus_addr_next_w;
		num_reg_r <= num_reg_w;
      end else begin
	    xbus_addr_r <= xbus_addr_r;
		num_reg_r <= num_reg_r;
	  end
    end else if (efuse_fsm_r == MAIN_READ) begin
      if (fsm_cnt_r == 3) begin
	    xbus_addr_r <= xbus_addr_rd_next_w;
		num_reg_r <= num_reg_w;
      end else begin
	    xbus_addr_r <= xbus_addr_r;
		num_reg_r <= num_reg_r;
	  end
    end else if (efuse_fsm_r == FINISH_READ) begin
      xbus_addr_r <= xbus_addr_r;
	  num_reg_r <= num_reg_r;	
	end else if (efuse_fsm_r == OTP_DONE) begin
	  xbus_addr_r <= RW_ADDR;
	  num_reg_r <= 0;
	end else begin
	  xbus_addr_r <= ADDR_ARRAY[0];
	  num_reg_r <= 0;
	end
  end

assign num_reg_w = num_reg_r + 1;
assign xbus_addr_rd_next_w = (num_reg_r != num_of_reg) ? ADDR_ARRAY[num_reg_r] : ADDR_ARRAY[num_of_reg - 1];
assign xbus_addr_next_w = ((num_reg_w == num_of_reg) || (num_reg_w == num_of_reg + 1)) ? ADDR_ARRAY[num_of_reg - 1] : ADDR_ARRAY[num_reg_w];
assign o_xbus_addr = xbus_addr_r;

// generate otp_csb
// in idle mode, otp_csb is low
// in program or read mode, otp_csb is driven to high to start a transaction
always @(posedge sys_clk or negedge rst_n)
  begin
    if (rst_n == 0)
      efuse_csb_r <= 1'b1;
    else if (efuse_fsm_r == START_PGM) begin
      if (fsm_cnt_r == 2) efuse_csb_r <= 1'b0;
	end else if (efuse_fsm_r == FINISH_PGM) begin
	  if (fsm_cnt_r == 0) efuse_csb_r <= 1'b1;
    end else if (efuse_fsm_r == START_READ) begin
      if (fsm_cnt_r == 0) efuse_csb_r <= 1'b0;
	end else if (efuse_fsm_r == FINISH_READ) begin
	  if (fsm_cnt_r == 0) efuse_csb_r <= 1'b1;
    end else if (efuse_fsm_r == IDLE) begin
      efuse_csb_r <= 1'b1;
    end else efuse_csb_r <= efuse_csb_r;
  end

assign o_otp_csb = efuse_csb_r;
assign efuse_csb_w = efuse_csb_r;

// generate otp_strobe
// in program mode, otp_strobe is used as otp_pgm.
// in read mode, otp strobe is used as otp_sclk.
// Noted that otp_pgm and otp_sclk are discussed and presented in datasheet of eFuse 128 bits.
always @(posedge sys_clk or negedge rst_n)
  begin
    if (rst_n == 0)
      efuse_strobe_r <= 1'b0;
    else if (efuse_fsm_r == MAIN_PGM) begin
	  if (fsm_cnt_r == 0) efuse_strobe_r <= i_xbus_dout[efuse_no_bitline_r];
	  else if (fsm_cnt_r == TPGM) efuse_strobe_r <= 1'b0;
	  else efuse_strobe_r <= efuse_strobe_r;
	end else if (efuse_fsm_r == MAIN_READ) begin
	  if (fsm_cnt_r == 0) efuse_strobe_r <= 1'b1;
	  else if (fsm_cnt_r == 3) efuse_strobe_r <= 1'b0;
	  else efuse_strobe_r <= efuse_strobe_r;
	end else efuse_strobe_r <= 1'b0;
  end

assign o_otp_strobe = efuse_strobe_r;

// generate otp_load
// otp_load is used to turn on sense amplifier and load data into latch in read mode
// in idle and program mode, it should be low
always @(posedge sys_clk or negedge rst_n)
  begin
    if (rst_n == 0)
	  efuse_load_r <= 1'b0;
	else if (efuse_fsm_r == START_READ) begin
	  if (fsm_cnt_r == 0) efuse_load_r <= ~efuse_load_r;
	  else efuse_load_r <= efuse_load_r;
	end else if (efuse_fsm_r == FINISH_READ) begin 
	  if (fsm_cnt_r == 0) efuse_load_r <= ~efuse_load_r;
	  else efuse_load_r <= efuse_load_r;
	end else if (efuse_fsm_r == MAIN_READ) efuse_load_r <= efuse_load_r;
	else efuse_load_r <= 1'b0;
  end
 
assign o_otp_load = efuse_load_r; 
  
// generate o_otp_pgenb
// otp_pgenb is used to enable programming mode, 0-enable, 1-disable
// in idle and read mode, it should be high
always @(posedge sys_clk or negedge rst_n)
  begin
    if (rst_n == 0)
	  efuse_pgenb_r <= 1'b1;
	else if ((efuse_fsm_next_s == START_PGM) || (efuse_fsm_next_s == MAIN_PGM) || (efuse_fsm_next_s == FINISH_PGM))
	  efuse_pgenb_r <= 1'b0;
	else efuse_pgenb_r <= 1'b1;
  end
  
assign o_otp_pgenb = efuse_pgenb_r;

// generate o_otp_vddqsw
// o_otp_vddqsw is used to turn on LDO 2.5V for programming otp memory
// in idle and read mode, it must be low
always @(posedge sys_clk or negedge rst_n)
  begin
    if (rst_n == 0)
      efuse_vddq_r <= 1'b0;
	else if (efuse_fsm_r == START_PGM) begin
	  if (fsm_cnt_r == 0) efuse_vddq_r <= 1'b1;
	  else efuse_vddq_r <= efuse_vddq_r;
    end else if (efuse_fsm_r == FINISH_PGM) begin
	  if (fsm_cnt_r == 2) efuse_vddq_r <= 1'b0;
	  else efuse_vddq_r <= efuse_vddq_r;
	end else if (efuse_fsm_r == MAIN_PGM) begin
      efuse_vddq_r <= 1'b1;
    end else
      efuse_vddq_r <= 1'b0;
  end

assign efuse_vddq_w = efuse_vddq_r;
assign o_otp_vddqsw = efuse_vddq_r;

// load data from otp mem valid legally at falling edge of otp_strobe
// xbus_addr access to register file in this case must be sent at the moment
always @(posedge sys_clk or negedge rst_n)
  begin
    if (rst_n == 0) begin
      xbus_din_r <= 8'h00;
    end else if (efuse_fsm_r == MAIN_READ) begin
	  if (fsm_cnt_r == 3) xbus_din_r <= i_otp_q;
	  else xbus_din_r <= xbus_din_r;
	end else if (efuse_fsm_r == FINISH_READ) xbus_din_r <= xbus_din_r;
	else if (efuse_fsm_r == OTP_DONE) xbus_din_r <= RW_DATA;
	else xbus_din_r <= 8'h00;
  end

assign o_xbus_din = xbus_din_r; 

// generate write/read enable sent to reg file (apb slave)
always @(posedge sys_clk or negedge rst_n)
  begin
    if (rst_n == 0) begin
	  xbus_wr_r <= 1'b0;
	end else if ((efuse_fsm_r == MAIN_READ) || (efuse_fsm_r == OTP_DONE)) xbus_wr_r <= 1'b1;
	else xbus_wr_r <= 1'b0;
  end
  
assign o_xbus_wr = xbus_wr_r;

// generate otp_busy sent to apb mux (should be checked, why we need otp_busy in this case)
assign o_otp_busy = ((efuse_fsm_r == IDLE) || (efuse_fsm_r == WAIT_I2C)) ? 1'b0 : 1'b1;

endmodule
