`timescale 1ns/10ps
module test_mode_ctrl (
			sys_clk,		//system clock, 200MHz clock generated by LO
			rst_n,			//power on reset, active low
			i2c_busy, 		//signaling that there is i2c transaction or not
			reg_passcode, 	//register is used to write passcode
			run_test_mode 	//signaling that test mode can be accessed 
			);
			
input sys_clk;
input rst_n;
input i2c_busy;
input [7:0] reg_passcode;
output run_test_mode;

wire i2c_busy_n;

reg state_sw_en_r; //enable change state
wire state_sw_en_s;

wire sys_clk_ctr; //output of clock gate

reg i2c_busy_r1;
reg i2c_busy_r2;
wire i2c_busy_sync; //sync i2c_busy with sys_clk 
wire i2c_busy_sync_n;

typedef enum {IDLE, WRITTEN_P, WRITTEN_H, WRITTEN_S, WRITTEN_G, WRITTEN_N, WRITTEN_X, RUN} ctr_state;
ctr_state ctr_state_r, ctr_state_next_s;

parameter P = 8'h50;
parameter H = 8'h48;
parameter S = 8'h53;
parameter G = 8'h47;
parameter N = 8'h4E;
parameter X = 8'h58;

assign i2c_busy_n = ~i2c_busy;

// sync i2c_busy with sys_clk
always @(posedge sys_clk or negedge rst_n)
begin
  if (rst_n == 1'b0)
	begin
	  i2c_busy_r1 <= 1'b0;
	  i2c_busy_r2 <= 1'b0;
	end
  else
	begin
	  i2c_busy_r1 <= i2c_busy;
	  i2c_busy_r2 <= i2c_busy_r1;
	end
end
assign i2c_busy_sync = i2c_busy_r2;
assign i2c_busy_sync_n = ~i2c_busy_sync;

// implement clock gate 
CKLNQD8  CLOCK_GTATE_SYS_CLK (	.E(i2c_busy_sync_n),  //clock gate for sys_clk
								.TE(1'b0), 
								.CP(sys_clk), 
								.Q(sys_clk_ctr)
							 );

always @(posedge sys_clk_ctr or negedge i2c_busy_n)
begin
  if (i2c_busy_n == 1'b0)
    state_sw_en_r <= 1'b1;
  else
	state_sw_en_r <= 1'b0;
end
assign state_sw_en_s = state_sw_en_r;


always @(posedge sys_clk_ctr or negedge rst_n)
begin
  if (rst_n == 1'b0)
    ctr_state_r <= IDLE;
  else 
	ctr_state_r <= ctr_state_next_s;
end

always @(*)
begin
  case(ctr_state_r)
    IDLE:
      if (reg_passcode == P) // write to register value P
        ctr_state_next_s = WRITTEN_P;
      else
		ctr_state_next_s = IDLE;
	WRITTEN_P:
	  if (state_sw_en_s == 1'b1 && i2c_busy == 1'b0) 
	    begin
	      if (reg_passcode == H) 
		    ctr_state_next_s = WRITTEN_H;
		  else ctr_state_next_s = IDLE;
	    end 
	  else 
	    ctr_state_next_s = WRITTEN_P;
	WRITTEN_H:
	  if (state_sw_en_s == 1'b1 && i2c_busy == 1'b0) 
		begin
		  if (reg_passcode == S) //write to register value S
		    ctr_state_next_s = WRITTEN_S;
		  else
			ctr_state_next_s = IDLE;
		end
	  else
		ctr_state_next_s = WRITTEN_H;
	WRITTEN_S:
	  if (state_sw_en_s == 1'b1 && i2c_busy == 1'b0) 
	    begin
		  if (reg_passcode == G) //write to register value G
			ctr_state_next_s = WRITTEN_G;
	      else
			ctr_state_next_s = IDLE;
		end
	  else
		ctr_state_next_s = WRITTEN_S;
	WRITTEN_G:
	  if (state_sw_en_s == 1'b1 && i2c_busy == 1'b0) 
	    begin
		  if (reg_passcode == N) //write to register value N
			ctr_state_next_s = WRITTEN_N;
		  else
			ctr_state_next_s = IDLE;
		end
	  else
	    ctr_state_next_s = WRITTEN_G;
	WRITTEN_N:
	  if (state_sw_en_s == 1'b1 && i2c_busy == 1'b0) 
	    begin
		  if (reg_passcode == X) //write to register value X
			ctr_state_next_s = WRITTEN_X;
		  else
			ctr_state_next_s = IDLE;
		end
	  else
	    ctr_state_next_s = WRITTEN_N;
	WRITTEN_X:
	  if (i2c_busy == 1'b0)
		ctr_state_next_s = RUN;
	  else 
		ctr_state_next_s = WRITTEN_X;
	RUN:
		ctr_state_next_s = RUN;
	default:
		ctr_state_next_s = IDLE;
  endcase
			
end

// passcode is correct, entry test mode
assign run_test_mode = (ctr_state_r == RUN)? 1'b1 : 1'b0; 

endmodule